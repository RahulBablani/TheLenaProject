\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Plan\\Title of Project}

\author{Team \#, Team Name
		\\ Student 1 name and macid
		\\ Student 2 name and macid
		\\ Student 3 name and macid
}

\date{\today}

\input{../Comments}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

This document ...

\section{General Information}

\subsection{Purpose}

\subsection{Scope}

\subsection{Acronyms, Abbreviations, and Symbols}
	
\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Abbreviation} & \textbf{Definition} \\
\midrule
Abbreviation1 & Definition1\\
Abbreviation2 & Definition2\\
\bottomrule
\end{tabularx}

\end{table}

\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Term} & \textbf{Definition}\\
\midrule
Term1 & Definition1\\
Term2 & Definition2\\
\bottomrule
\end{tabularx}

\end{table}	

\subsection{Overview of Document}

\section{Plan}
	
\subsection{Software Description}

\subsection{Test Team}

\subsection{Automated Testing Approach}

\subsection{Testing Tools}
\begin{itemize}
\item J-Unit will be implemented as the primary testing framework to run tests on all sections of the code.
\item Different images and file types will be used to test the file input and output of the application.
\item Black box testing will be done on Windows, Mac, and Linux based operating systems to ensure all functional and non-functional requirements are fulfilled on all platforms.
\end{itemize}

\subsection{Testing Schedule}
		
See Gantt Chart at the following url ...

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}

\subsubsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: 
					
Initial State: 
					
Input/Condition: 
					
Output/Result: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\section{Tests for Proof of Concept}

\subsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsection{Area of Testing2}

...

	
\section{Comparison to Existing Implementation}	
				
\section{Unit Testing Plan}
		
\subsection{Unit testing of internal functions}

Our project as of now has one internal function (besides the "main" function).
This internal function is the \textbf{actionPerformed} function used to listen to the actions in the GUI. There are a series of if-statements for the logic connecting each button to the correct plug-ins, and subsequently applying the correct filters to the image, resetting the image back to it original state, or prompting the user to save the edited image whilst choosing a name and a destination for it.

There are 3 types of buttons associated to the GUI: filter buttons, a reset button, and a save button. The unit tests for this function will be reflected differently based on the type of button. For the filter buttons we will be testing the correctness of the filter applied based on the selected filter. We will test from different initial states, one where the photo is in its original state right before the filter is applied, and other where the photo has already been edited by another filter and the filter is being applied on top of that. The unit test will only pass if the correctly selected filter was applied without making any other alterations to the photo. The second type of button is the reset button, the unit test for this will be testing the correctness of the "reset" from any initial state and will only pass if the image is is fully restored to its original state. The final type of button is the save button. There will be two unit tests for this. The first one will be testing the checking if the user is prompted with the export interface to save their edited image, and will only pass if the interface is made available for the user. The second unit test is linked to the output files and will be explained in the next subsection (6.2 Unit testing of output files).
		
\subsection{Unit testing of output files}		

The only output file generated in this project is the processed version of the image that the user desires to save to their local drive. This is possible through the save button, which subsequently prompts the user with the export interface where they can select the image type, destination folder, and name of the finished product. The first unit test for the save button was discussed in the previous subsection (6.1 Unit testing of internal functions), but as stated there, there is a second unit test which is linked to the output files. This will be testing the reliability, compatibility, as well as the actual correctness of the output file. The unit test will pass if, after the prompting for export, the image is save with the correct formatting, with the right file path, and that the image is identical to how it looked in the preview window (with selected filters applied to it). This must consistently, work as well have some error handling to be able to notify the user if the selected format, file path, chosen name are invalid.

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}